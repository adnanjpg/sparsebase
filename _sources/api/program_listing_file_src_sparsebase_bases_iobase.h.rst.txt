
.. _program_listing_file_src_sparsebase_bases_iobase.h:

Program Listing for File iobase.h
=================================

|exhale_lsh| :ref:`Return to documentation for file <file_src_sparsebase_bases_iobase.h>` (``src/sparsebase/bases/iobase.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #include <algorithm>
   #include <cstring>
   #include <fstream>
   #include <string>
   #include <utility>
   #include <vector>
   
   #include "sparsebase/config.h"
   #include "sparsebase/format/format.h"
   #include "sparsebase/format/format_order_one.h"
   #include "sparsebase/format/format_order_two.h"
   #include "sparsebase/io/binary_reader_order_one.h"
   #include "sparsebase/io/binary_reader_order_two.h"
   #include "sparsebase/io/binary_writer_order_one.h"
   #include "sparsebase/io/binary_writer_order_two.h"
   #include "sparsebase/io/edge_list_reader.h"
   #include "sparsebase/io/mtx_reader.h"
   #include "sparsebase/io/pigo_edge_list_reader.h"
   #include "sparsebase/io/pigo_mtx_reader.h"
   #include "sparsebase/io/reader.h"
   #include "sparsebase/io/writer.h"
   
   #ifndef SPARSEBASE_PROJECT_IOBASE_H
   #define SPARSEBASE_PROJECT_IOBASE_H
   
   namespace sparsebase::bases {
   class IOBase {
    public:
   
     template <typename IDType, typename NNZType, typename ValueType>
     static format::CSR<IDType, NNZType, ValueType>* ReadMTXToCSR(
         std::string filename, bool convert_index_to_zero = true) {
       io::MTXReader<IDType, NNZType, ValueType> reader(filename,
                                                        convert_index_to_zero);
       return reader.ReadCSR();
     }
   
     template <typename IDType, typename NNZType, typename ValueType>
     static format::COO<IDType, NNZType, ValueType>* ReadMTXToCOO(
         std::string filename, bool convert_index_to_zero = true) {
       io::MTXReader<IDType, NNZType, ValueType> reader(filename,
                                                        convert_index_to_zero);
       return reader.ReadCOO();
     }
   
     template <typename IDType, typename NNZType, typename ValueType>
     static format::Array<ValueType>* ReadMTXToArray(
         std::string filename, bool convert_index_to_zero = true) {
       io::MTXReader<IDType, NNZType, ValueType> reader(filename,
                                                        convert_index_to_zero);
       return reader.ReadArray();
     }
   
   
     template <typename IDType, typename NNZType, typename ValueType>
     static format::CSR<IDType, NNZType, ValueType>* ReadPigoMTXToCSR(
         std::string filename, bool weighted, bool convert_index_to_zero = true) {
       io::PigoMTXReader<IDType, NNZType, ValueType> reader(filename, weighted,
                                                            convert_index_to_zero);
       return reader.ReadCSR();
     }
     template <typename IDType, typename NNZType, typename ValueType>
     static format::COO<IDType, NNZType, ValueType>* ReadPigoMTXToCOO(
         std::string filename, bool weighted, bool convert_index_to_zero = true) {
       io::PigoMTXReader<IDType, NNZType, ValueType> reader(filename, weighted,
                                                            convert_index_to_zero);
       return reader.ReadCOO();
     }
     template <typename IDType, typename NNZType, typename ValueType>
     static format::CSR<IDType, NNZType, ValueType>* ReadPigoEdgeListToCSR(
         std::string filename, bool weighted) {
       io::PigoEdgeListReader<IDType, NNZType, ValueType> reader(filename,
                                                                 weighted);
       return reader.ReadCSR();
     }
     template <typename IDType, typename NNZType, typename ValueType>
     static format::COO<IDType, NNZType, ValueType>* ReadPigoEdgeListToCOO(
         std::string filename, bool weighted) {
       io::PigoEdgeListReader<IDType, NNZType, ValueType> reader(filename,
                                                                 weighted);
       return reader.ReadCOO();
     }
   
   
     template <typename IDType, typename NNZType, typename ValueType>
     static format::CSR<IDType, NNZType, ValueType>* ReadEdgeListToCSR(
         std::string filename, bool weighted = false,
         bool remove_self_edges = false, bool read_undirected = true,
         bool square = false) {
       io::EdgeListReader<IDType, NNZType, ValueType> reader(
           filename, weighted, true, remove_self_edges, read_undirected, square);
       return reader.ReadCSR();
     }
   
     template <typename IDType, typename NNZType, typename ValueType>
     static format::COO<IDType, NNZType, ValueType>* ReadEdgeListToCOO(
         std::string filename, bool weighted = false,
         bool remove_self_edges = false, bool read_undirected = true,
         bool square = false) {
       io::EdgeListReader<IDType, NNZType, ValueType> reader(
           filename, weighted, true, remove_self_edges, read_undirected, square);
       return reader.ReadCOO();
     }
   
   
     template <typename IDType, typename NNZType, typename ValueType>
     static format::CSR<IDType, NNZType, ValueType>* ReadBinaryToCSR(
         std::string filename) {
       io::BinaryReaderOrderTwo<IDType, NNZType, ValueType> reader(filename);
       return reader.ReadCSR();
     }
   
     template <typename IDType, typename NNZType, typename ValueType>
     static format::COO<IDType, NNZType, ValueType>* ReadBinaryToCOO(
         std::string filename) {
       io::BinaryReaderOrderTwo<IDType, NNZType, ValueType> reader(filename);
       return reader.ReadCOO();
     }
   
   
     template <typename ValueType>
     static format::Array<ValueType>* ReadBinaryToArray(std::string filename) {
       io::BinaryReaderOrderOne<ValueType> reader(filename);
       return reader.ReadArray();
     }
   
   
     template <typename IDType, typename NNZType, typename ValueType>
     static void WriteCOOToBinary(format::COO<IDType, NNZType, ValueType>* coo,
                                  std::string filename) {
       io::BinaryWriterOrderTwo<IDType, NNZType, ValueType> writer(filename);
       return writer.WriteCOO(coo);
     }
   
     template <typename IDType, typename NNZType, typename ValueType>
     static void WriteCSRToBinary(format::CSR<IDType, NNZType, ValueType>* csr,
                                  std::string filename) {
       io::BinaryWriterOrderTwo<IDType, NNZType, ValueType> writer(filename);
       return writer.WriteCSR(csr);
     }
   
     template <typename ValueType>
     static void WriteArrayToBinary(format::Array<ValueType>* array,
                                    std::string filename) {
       io::BinaryWriterOrderOne<ValueType> writer(filename);
       return writer.WriteArray(array);
     }
   };
   }  // namespace sparsebase::bases
   #endif  // SPARSEBASE_PROJECT_IOBASE_H
